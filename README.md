# "Isomorph" structs conversions generator

The utility generates conversion functions between primary and secondary structures based on fields names and type 
matching with a dedicated support of types generated with `protoc-gen-go`.


## Installation

```shell
go install github.com/sirkon/metamorph@latest
```

## Glossary and definitions

* Primary structure is one that will have conversion functions in its package.
* Secondary structure is one that may not have generated conversions in its package.
* Primary package is the package containing primary structure.
* Secondary package is the package containing secondary structure.
* Types `A` and `B` are can be matched (`A` ≈ `B`) if they meet one of the following criteria:
  * `A` == `B` 
  * `A` is a pointer of `B` or vice versa
  * There is a function or method with no parameters besides `A` itself to convert `A` (or `*A`) into `B` or `*B`
  * `[]A` ≈ `[]B` if `A` ≈ `B`
  * `map[X]A` ≈ `map[Y]B` if `A` ≈ `B` and `X` == `Y`
* Field names `X` and `Y` are matchable if they are both Go-public and `gogh.Underscored(X)` == `gogh.Underscored(Y)`

### TODO

Need to extend from `matchability` to `equivalency` once that will add transitivity what would mean the generator will 
be able to make a chain of conversions for equivalent types, not just direct ones. I mean, if there are

* types `A`, `B`, `C`
* functions `f: A -> B`, `f': B -> A` and `g: B -> C`, `g': C -> B`

then the generator will know `A` and `C` are matchable via `g∘f: A -> C` and `f'∘g': C -> A`. This will be a true 
relation of equivalency.

## Usage

* You must be within a module containing a primary package
* Just run
  ```shell
  metamorph generate primary/path:Primary secondary/path:Secondary
  ```
* You may run `isomorph install-completions` to use bash/zsh/whatever completions of packages and structs names. 
* There should be no full match. If some fields in either of structs has no match the call of not existing func will be 
generated, you will need to create that func and add missing conversions yourself.  

Also, remember, if: 
* the secondary struct is generated by `protoc-gen-go`
* have a field related to `oneof` of proto
* there are fields with matchable names and types for all branches of this `oneof`

Then the generator will make proper conversions for them too.